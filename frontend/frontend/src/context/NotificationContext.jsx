import { createContext, useContext, useState, useCallback, useEffect } from "react";
import api, { API_URL } from "../api";
import { useAuth } from "./AuthContext";

const NotificationContext = createContext();

export const NotificationProvider = ({ children }) => {
  const { auth } = useAuth();
  // Fetch notifications on mount/auth change
  const [notifications, setNotifications] = useState([]);

  // Direct access to userId from auth state
  const userId = auth?.user?.id || auth?.id;

  useEffect(() => {
    const fetchNotifications = () => {
      if (userId) {
        console.log("Fetching notifications for userId:", userId);
        api.get(`/notifications?userId=${userId}`)
          .then(res => {
            setNotifications(res.data);
          })
          .catch(err => {
            console.error("Fetch notifications failed", err);
          });
      }
    };

    fetchNotifications();
    const interval = setInterval(fetchNotifications, 30000); // Poll every 30 seconds

    return () => clearInterval(interval);
  }, [userId]);
  // Dependency on userId is more precise than [auth]

  const addNotification = useCallback(async (notification) => {
    if (!userId) {
      console.warn("Attempted to add notification without userId");
      return;
    }

    // Optimistic UI update
    const tempId = Date.now();
    const newNotif = { ...notification, id: tempId, timestamp: new Date(), read: false };
    setNotifications((prev) => [newNotif, ...prev]);

    try {
      const res = await api.post("/notifications", {
        userId,
        type: notification.type,
        title: notification.title,
        message: notification.message
      });

      // Update the temp notification with real ID from backend
      const realNotification = res.data;

      setNotifications(prev => {
        // Find the temp notification in the LATEST state to see if user marked it as read
        const tempNotif = prev.find(n => n.id === tempId);
        const isReadLocally = tempNotif?.read || false;

        // If user marked it read locally while request was in-flight, sync that to backend
        if (isReadLocally) {
          api.patch(`/notifications/${realNotification.id}/read`).catch(e => console.error("Sync read failed", e));
        }

        return prev.map(n =>
          n.id === tempId ? { ...n, id: realNotification.id, timestamp: realNotification.timestamp, read: isReadLocally } : n
        );
      });
    } catch (err) {
      console.error("Save notification failed", err);
      // Remove the optimistic notification on failure to ensure UI consistency
      setNotifications(prev => prev.filter(n => n.id !== tempId));
    }

    // Auto-remove success toasts from UI (but keep in DB? actually UI usually hides toasts)
    // If we want detailed history, we shouldn`t remove them from state, just hide the toast.
    // For now, let's keep the toast behavior:
    if (notification.type === 'success') {
      setTimeout(() => {
        // removeNotification(tempId); // Do not remove from history, just from toast view?
        // The current context mixes Toast + History. 
        // Let's assume this contexts manages the "Notification Center" list.
        // If we remove it here, it's gone from history too.
        // Let's NOT remove it automatically from state if we want history persistence.
        // But we want the "Toast" to disappear.
        // Usually there's a separate "Toast" state vs "History" state.
        // For this MVP, let's just NOT auto-remove from list so user can see history.
      }, 5000);
    }
  }, []);

  const removeNotification = useCallback(async (id) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
    try {
      if (id > 1700000000000) return; // Skip temp IDs if not synonymous
      await api.delete(`/notifications/${id}`);
    } catch (err) {
      console.error("Delete notification failed", err);
    }
  }, []);

  const markAsRead = useCallback(async (id) => {
    setNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, read: true } : n))
    );
    try {
      // Only send to backend if it`s a real ID (from DB)
      // Our temp IDs are Date.now() which are large numbers, but real IDs are usually smaller DB auto-inc/UUIDs. 
      // Better check: we know temp IDs are generated by Date.now().
      // Actually, simplest is to just try-catch or check if we have it.
      // But wait, if we send a huge number to backend it might just 404 which is fine.
      // The issue is if the backend ID *becomes* available later.
      // For now, let's just send it. If it 404s, it defaults to "ignore".
      // But we can slightly optimize:
      await api.patch(`/notifications/${id}/read`);
    } catch (err) { console.error("Mark read failed", err); }
  }, []);

  const markAllAsRead = useCallback(async () => {
    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
    try {
      if (userId) {
        await api.patch(`/notifications/read-all?userId=${userId}`);
      }
    } catch (err) {
      console.error("Mark all read failed", err);
    }
  }, [userId]);

  const clearAll = useCallback(async () => {
    setNotifications([]);
    try {
      if (userId) {
        await api.delete(`/notifications?userId=${userId}`);
      }
    } catch (err) {
      console.error("Clear all notifications failed", err);
    }
  }, [userId]);

  const unreadCount = notifications.filter((n) => !n.read).length;

  return (
    <NotificationContext.Provider
      value={{
        notifications,
        addNotification,
        removeNotification,
        markAsRead,
        markAllAsRead,
        clearAll,
        unreadCount,
      }}
    >
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotifications = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error("useNotifications must be used within NotificationProvider");
  }
  return context;
};

